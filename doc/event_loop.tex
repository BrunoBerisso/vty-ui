\section{The vty-ui Event Loop}

Vty-ui manages the user input event loop for you, and once you have
created and populated a collection, you can invoke the main vty-ui event
loop:

\begin{minted}{haskell}
runUi c defaultContext
\end{minted}

The first parameter is the collection you have created; the second
parameter is the 'rendering context'.  Here we use the 'default'
rendering context provided by the library.  The rendering context
provides three key pieces of functionality:

\begin{itemize}
\item The "skin" to use when rendering ASCII lines, corners, and
      intersections
\item The default "normal" (unfocused) attribute
\item The default "focused" attribute
\end{itemize}

\subsection{Skinning}

Some widgets, such as the table widget and the horizontal and vertical
border widgets, use line-drawing characters to draw borders between
interface elements.  Some terminal emulators are capable of drawing
Unicode characters, which make for nicer-looking line-drawing.  Other
terminal emulators work best only with ASCII.  The default rendering
context uses a Unicode line-drawing skin, which you can change to any
other skin (or your own) as follows:

\begin{minted}{haskell}
runUi c $ defaultContext { skin = asciiSkin }
\end{minted}

The library provides skins in the 'Skin' module.

\subsection{Attributes}

The default attributes specified in the skin control how widgets appear.
An attribute may consist of one or more settings of foreground and
background color and text style, such as underline or blink.

Every widget has the ability to store its own normal and focused
attributes.  When widgets are rendered, they use these attributes; if
they are not set, the widgets default to using those specified by the
rendering context.  Widgets provide an API for setting these attributes
using the 'HasNormalAttr' and 'HasFocusAttr' type classes.  The reason
we use type classes to provide this API is so that third-party widgets
may also provide this functionality.  The API is defined in the 'Core'
module and is as follows:

\begin{minted}{haskell}
setNormalAttribute w attr
setFocusAttribute w attr
\end{minted}

Convenience combinators also exist:

\begin{minted}{haskell}
w <- someWidget
     >>= withNormalAttribute attr
     >>= withFocusAttribute attr
\end{minted}

The 'attr' value is a Vty attribute value.  A Vty attribute may provide
any (but not necessarily all!) of the settings that make up an
attribute; any setting not specified (e.g. background color) can fall
back to the default.  As a result, the attribute of a widget is the
*combination* of its attribute and the attribute from the rendering
context.  The widget's settings will take precedence, but any setting
not provided will default to the rendering context.

Consider this example:

\begin{minted}{haskell}
w <- someWidget
setNormalAttribute w (fgColor white)

-- ... add the widget to a collection, etc.
runUi c $ defaultContext { normalAttr = yellow `on` blue }
\end{minted}

In this example, the widget 'w' will use a normal attribute of white on
a blue background, since it specified only a foreground color as its
normal attribute.  This kind of precedence allows you to very easily
maintain consistency across your entire interface.

In addition, container widgets are designed to pass their normal and
focused attributes onto their children during the rendering process;
this way, unless a child specifies an override with 'setNormalAttribute'
or similar, it uses its parent's attributes.  Again, this facilitates
consistency across the interface while only requiring the you to specify
attributes where you want to deviate from the default.

You can create attributes with varying levels of specificity by using
the vty-ui API:

XXX make this a table
\begin{minted}{haskell}
fgColor blue -- foreground only
bgColor blue -- background only
style underline -- style only
blue `on` red -- foreground and background
someAttr `withStyle` underline -- adding a style
\end{minted}

The Vty 'def\_attr' value's default configuration is used as a basis for
all partially-specified attributes.  The functions described above are
defined in the 'Util' module.

\subsection{\texttt{vty-ui} and Concurrency}
\label{sec:concurrency}

So far we have only seen programs which modify widget state when user
input events occur.  Such changes in widget state are safe, because
they are triggered by the 'vty-ui' event loop.  However, your program
will more than likely need to trigger some widget state changes due to
other external events -- such as network events -- and 'vty-ui'
provides a mechanism for doing this in a thread-safe way.

'vty-ui' provides a function in the 'Core' module called 'schedule'
which takes an 'IO' action and ``schedules'' it to be run by the main
event loop.  It will be run as soon as possible, once the program
control flow has returned to the event loop.  Since the scheduled
action will be run by the event loop, it's important that the action
not take very long; if it's important to block (e.g., by calling
'threadDelay'), you should do that in a thread and only call
'schedule' when you have work to do.

Consider this example, in which a text widget called 'timeText' gets
updated with the current time every second:

\begin{minted}{haskell}
forkIO $
  forever $ do
    schedule $ do
      t <- getCurrentTime
      setText timeText $
        formatTime defaultTimeLocale rfc822DateFormat t
    threadDelay 1000000
\end{minted}

In this example the blocking occurs outside of the scheduled code, and
only when we have an update for the clock display do we schedule an
action to run.

Some built-in widgets will almost always be used in this way; for an
example, take a look at the 'ProgressBar' widget in the 'ProgressBar'
module.

\subsection{Managing Your Own State}

Vty-ui provides a lot of functionality, but of course the only truly
useful applications you write will have their own state and will use
that state to update the terminal interface.  Accomplishing this will
require use of the 'schedule' function mentioned in Section
\ref{sec:concurrency}.

A typical design for applications using Vty-ui is:

\begin{itemize}
\item The application defines its own state type, call it 'AppState'.
\item The 'AppState' type has fields for the various widgets that need
  to be mutated over the course of the application's execution; for
  example, lists, progress bars, radio buttons, check boxes, etc.
\item Various event handlers are set up on these and other widgets.
\item The application spawns one or more threads to manage events from
  external sources, and when these events occur, actions are scheduled
  to update the interface state accordingly.
\item The main event loop is executed and control is passed to the
  library.
\end{itemize}
