\section{Deferring to Child Widgets}

Widget-wrapping widget types are common in \fw{vty-ui}, since we use
this technique to influence rendering and other behaviors.  As a
result, when implementing a wrapper widget it is important to decide
which behaviors should be deferred to the child widget and which
behaviors should be overridden.

In this section we'll create a wrapper widget type called \fw{Wrapper}
and we'll implement all of its behaviors to illustrate how the
behaviors can be deferred in each case.

We'll start with the type.\footnote{A \fw{newtype} would work just as
  well.}  We provide a function to get the child to make it easier to
deal with:

\begin{minted}{haskell}
data Wrapper a = Wrapper { wrappedChild :: Widget a }
\end{minted}

Then the implementation of the constructor:\footnote{This widget
  implementation uses the ``relaying'' functions we described in
  Section \ref{sec:containers_and_input}.}

\begin{minted}{haskell}
newWrapper :: (MonadIO m) => Widget a -> m (Widget (Wrapper a))
newWrapper child = do
  wRef <- newWidget
  updateWidget wRef $ \w ->
    w { state = Wrapper child
      , growHorizontal_ = growHorizontal child
      , growVertical_ = growVertical child
      , setCurrentPosition_ =
          \_ pos = setCurrentPosition child pos
      , cursorInfo =
          const $ getCursorPosition child
      , render_ =
          \_ sz ctx = do
            render child sz ctx
      }

  wRef `relayFocusEvents` child
  wRef `relayKeyEvents` child
  return wRef
\end{minted}

This demonstration highlights some important features of container
widget implementations:

\begin{itemize}
\item The state type of the wrapped widget, \fw{a}, is preserved in
  the type of the wrapper widget itself.
\item We referred directly to \fw{child} instead of using
  \fw{getState} in all of the functions; the reason is because we
  don't care about allowing the child to be replaced with a different
  widget.  If that is something you want to support, then you
  \textit{must} use \fw{getState} to ensure that you have the latest
  version of the widget's state and, as a result, the correct child
  widget reference.
\item We defer all behaviors to the child: growth policy, rendering,
  positioning, and cursor behavior.  Most container widgets defer all
  of these things.
\end{itemize}

In some cases -- such as with \fw{Centered} widgets or anything that
adds padding -- the growth policies will need to be changed to reflect
how the final result should be laid out.  In those cases, it is
sufficient to provide an implementation for the growth policy
functions that returns the desired value rather than calling that of
the child widget.
