\section{Deferring to Child Widgets}

Widget-wrapping widget types are common in \fw{vty-ui}, since we use
this technique to influence rendering and other behaviors.  As a
result, when implementing a wrapper widget it is important to decide
which behaviors should be deferred to the child widget and which
behaviors should be overridden.

In this section we'll create a wrapper widget type called \fw{Wrapper}
and we'll implement all of its behaviors to illustrate how the
behaviors can be deferred in each case.

We'll start with the type.\footnote{A \fw{newtype} would work just as
  well.}  We provide a function to get the child to make it easier to
deal with:

\begin{minted}{haskell}
data Wrapper a = Wrapper { wrappedChild :: Widget a }
\end{minted}

Then the implementation of the constructor:

\begin{minted}{haskell}
newWrapper :: (MonadIO m) => Widget a -> m (Widget (Wrapper a))
newWrapper child = do
  wRef <- newWidget
  updateWidget wRef $ \w ->
    w { state = Wrapper child
      , growHorizontal_ = growHorizontal . wrappedChild
      , growVertical_ = growVertical . wrappedChild
      , setCurrentPosition_ =
          \this pos = do
            st <- getState this
            setCurrentPosition (wrappedChild st) pos
      , cursorInfo =
          \this ->
            st <- getState this
            getCursorPosition (wrappedChild st)
      , render_ =
          \this sz ctx = do
            st <- getState this
            render (wrappedChild st) sz ctx
      }

  wRef `relayFocusEvents` child
  wRef `relayKeyEvents` child
  return wRef
\end{minted}

This widget implementation uses the ``relaying'' functions we
described in Section \ref{sec:containers_and_input}.
