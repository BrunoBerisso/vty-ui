
- Widgets:

  - Scrollable area (a generalization of the List) which can wrap a
    widget and make it scrollable in a confined space.  To make this
    work, we may need masking support in Vty.  Scrolling is really
    just (top, left, widget, mask window size) where the window size
    depends on available space and top/left positions are modified by
    the application as scrolling requests are received.

  - horizontal / vertical boxes which can take absolute values or
    percentages to determine how to allocate space to their children
    (this may entail re-tooling the existing types to take one of
    various space allocation specifiers).  Maybe something like:

    Size = Absolute Int Int
         | Percent Int
         | Auto
    (Widget a, Widget b) => HBox Size a b

    Sizing policy (Size) determines how a box reserves space for each
    of its two children.  Percent a implies (100-a) percent space
    allocated for one child.  Absolute a b implies a rows or columns
    for the "first" child and b rows or columns for the "second"
    child.  Auto implies that the box may grow to accomodate the size
    of its children.

  - table widget for laying out name/value pairs in nice format

  - support for right-aligning text (just left-padding?)

  - support for text processing and attribute assignment (e.g., how
    links and e-mail addresses are highlighted in mutt).  In general,
    it might be nice to take the WrappedWidget and generalize it into
    TransformedText which takes a transformation function.  For text
    highlighting it would be great if we could use a parsec parser to
    locate and highlight all matches.  Then you could write
    non-trivial parsers to determine what to highlight.

- Vty support for concurrently injecting user-defined event types into
  the next_event (Event) process.  It looks like Vty already uses
  multiple threads to collect and inject events anyway, so we could
  patch Vty to wait on concurrently-injected user-defined events; this
  will involve changing Event to be Event a for some user-defined
  event type a.

  See Graphics.Vty.Terminal.LLInput

  (patch submitted to vty author; awaiting review)

- Maybe use RenderState data and mouse events to detect which
  addressable widget was clicked?
