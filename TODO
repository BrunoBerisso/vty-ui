
- Rewriting tasks:

  - List: do audit for calculations that should be done in terms of
    itemHeight

  - support for right-aligning text (just left-padding?)

  - Table cell properties (maybe fold this into the Cell size spec
    type?):

    - padding
    - alignment

  - When a table has N columns with an edit widget in the Nth column
    and no edge border, the underline attribute goes to the right side
    of the terminal. :( Perhaps enclose the edit area in [...]?  Is
    this a VTY bug where the formatting should be terminated
    explicitly?

  - Tables: richer API

    - add, remove rows
    - get reference to cell contents
    - events: onRowAdded, onRowRemoved

  - Think about possible ways to link the size of one widget (say,
    text) to another (say, a table).  Right now you have to use an
    hLimit or vLimit, but if you don't want to hard-code a size that
    can be ugly.  The trouble with doing this is that if widget A
    depends on the size of B but due to the UI layout A needs to be
    rendered before B, then it's impossible to depend on the current
    dimensions of B.

  - Fix bug: text widget wrapping does not correctly preserve
    preexisting newlines.  Could just be a tokenization bug.  Tests
    would be nice here...

  - Fix ugliness: text tokenization truncates whole tokens when
    limiting what to render (instead of truncating mid-token)

  - Fix bug(s): some widgets crash when they can't be rendered (i.e.,
    they return images anyway, but there is no space).  Start by
    adding a check in the render function to blow up and hopefully
    provide some info about the violation.  Table is known buggy this
    area.

  - Use Text instead of String?  (And encode Text as Utf8, which Vty
    supports)

  - Think about how to enforce restrictions on what can go in table
    cells.  Could check growHorizontal and growVertical of things that
    get added and raise an exception.

  - Exception types: add more metadata to each constructor, add custom
    Show instances to make the errors more useful

  - Think about ways to improve the UI construction interface.  E.g.,

    class (MonadIO m) => Liftable a m b | a -> m b where
        getThing :: a -> m (Widget b)

    instance (MonadIO m) => Liftable (m (Widget a)) m a where
        getThing = id

    instance (MonadIO m) => Liftable (Widget a) m a where
        getThing = return

    (<-->) :: (MonadIO m, Liftable w1 m a, Liftable w2 m b) =>
              w1
           -> w2
           -> m (Widget (Box a b))
    (<-->) act1 act2 = do
      ch1 <- getThing act1
      ch2 <- getThing act2
      vBox ch1 ch2

    (<++>) :: (MonadIO m, Liftable w1 m a, Liftable w2 m b) =>
              w1
           -> w2
           -> m (Widget (Box a b))
    (<++>) act1 act2 = do
      ch1 <- getThing act1
      ch2 <- getThing act2
      hBox ch1 ch2

- Low priority:

  - Layering (i.e., dialogs), probably needs research into transposed
    images in Vty (which are not implemented yet).  Once dialogs work,
    we could make them fancy and modal by rendering the underlying UI
    in black and white and the dialog in color!

  - Ability to clear (reset) key event handler on a widget

  - Support for "showing" and "hiding" widgets

  - Generalize borders by adding "spacing" widgets that add a number
    of rows or columns of space on a given side of a widget.  This is
    already basically possible with vBorderWith ' ' and hBorderWith '
    ', but it would also be nice to make these explicit and add a
    "bordered"-style box spacing wrapping widget type.

  - Scrollable area (a generalization of the List) which can wrap a
    widget and make it scrollable in a confined space.  To make this
    work, we may need masking support in Vty.  Scrolling is really
    just (top, left, widget, mask window size) where the window size
    depends on available space and top/left positions are modified by
    the application as scrolling requests are received.

  - Consider rewriting table to use boxes instead of direct layout;
    could greatly simplify the positioning!  You'd just need to do
    some limiting on the cell contents and padding where appropriate.
    Later: except it's not that simple; if you're going to use boxes,
    then you end up packaging up all the widgets and never actually
    drawing them, since Box does that.  But then you don't know how
    high each row is, so you don't know how to construct the borders
    in between cells, since they depend on the maximum cell height for
    each row.  And so on.

- Testing:

  - Ugh.  Need loads of tests for tricky things.
